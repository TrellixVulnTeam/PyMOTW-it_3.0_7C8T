<?xml version="1.0" encoding="Latin-1"?>
<target>3</target>
<categoria>Testo</categoria><!-- # tag <descrizione> contiene le voci per la tabella di riepilogo iniziale -->
<!-- # tag <titolo_1> titolo principale -->
<!-- # tag <titolo_1> titolo principale -->
<!-- tag <testo_normale> contiene il testo normale dell'articolo -->
<!-- tag <titolo_2> contiene il testo per l'intestazione di un paragrafo -->
<!-- tag <py_code> contiene il testo che rappresenta delle istruzioni python -->
<!-- tag <py_output> contiene il testo che rappresenta l'outpuy di uno script python -->
<!-- tag <vedi_anche> contiene il testo che rappresentano i riferimenti esterni -->
<documento_tradotto>
<titolo_1>
re - Espressioni Regolari
</titolo_1>
<descrizione>
Cercare e/o modificare del testo usando modelli formali

</descrizione>
<testo_normale>
Le <a href='http://it.wikipedia.org/wiki/Espressione_regolare'>espressioni regolari</a>  sono dei modelli, descritti con una sintassi formale, per cercare corrispondenze in un testo. I modelli sono interpretati come un insieme di istruzioni, le quali sono poi eseguite con una stringa come input per produrre un sotto insieme di corrispondenze oppure una versione modificata della stringa originale. Il termine &quot;espressione regolare&quot; (regular expression in inglese - n.d.t.) viene spesso abbreviato come &quot;regex&quot; oppure &quot;regexp&quot; nella conversazione. Le espressioni possono comprendere corrispondenza letterale del testo, ripetizione, composizione di modello, diramazione ed altre sofisticate regole. Un grande numero di problemi di elaborazione di testo sono più semplici da risolvere usando una espressione regolare invece che creare un analizzatore ed elaboratore lessicale per lo scopo specifico.
</testo_normale>
<testo_normale>
Le espressioni regolari sono tipicamente usate in applicazioni che necessitano di molta elaborazione di testo. Ad esempio sono comunemente usate come modelli di ricerca in programmi per la modifica di testo (text editors) usati dagli sviluppatori, compreso vi, emacs fino ai moderni ambienti integrati di programmazione (IDE). Sono anche parte integrante di utilità da riga di comando UNIX tipo <em>sed</em>, <em>grep</em> ed <em>awk</em>. Molti linguaggi di programmazione includono il supporto per le espressioni regolari nella sintassi del linguaggio (Perl, Ruby, Awk e Tcl). Altri linguaggi tipo C, C++ e Python supportano le espressioni regolari attraverso librerie di estensione.
</testo_normale>
<testo_normale>
Ci sono varie implementazioni open source di espressioni regolari, ognuna delle quali condivide una sintassi base ma con diverse estensioni o modifiche rispetto alla loro caratteristiche avanzate. La sintassi usata nel modulo Python <strong>re</strong> si basa sulla sintassi usata nelle espressioni regolari in Perl, con pochi arricchimenti specifici di Python.
</testo_normale>
<note>
Sebbene la definizione formale di &quot;espressione regolare&quot; sia limitata ad espressioni che descrivono linguaggi normali, alcune delle estensioni supportate da <strong>re</strong> vanno oltre la descrizione dei linguaggi normali. Il termine "espressione regolare" viene qui usato in senso più generale e vuol dire qualsiasi espressione che possa essere elaborata del modulo <strong>re</strong> di Python.
</note>
<titolo_2>
Trovare Corrispondenze nel Testo
</titolo_2>
<testo_normale>
L'uso più comune per <strong>re</strong> è la ricerca di modelli nel testo. La funzione <code>search()</code> riceve un modello ed il testo da cercare, e ritorna un oggetto <code>Match</code> quando viene trovato il modello; in caso contrario <code>search()</code> ritorna <code>None</code>..
</testo_normale>
<testo_normale>
Ciascun oggetto <code>Match</code> contiene informazioni circa la natura della corrispondenza, compresa la stringa in input originale, l'espressione regolare utilizzata, ed il punto all'interno della stringa originale dove si trova il modello cercato.
</testo_normale>
<py_code>
# re_simple_match.py

import re

pattern = 'questo'
text = 'questo testo ha corrispondenza nel modello?'

match = re.search(pattern, text)

s = match.start()
e = match.end()

print('Trovato "{}"\nin "{}"\nda {} a {} ("{}")'.format(
    match.re.pattern, match.string, s, e, text[s:e]))
</py_code>
<testo_normale>
I metodi <code>start()</code> ed <code>end()${</code> forniscono gli indici all'interno della stringa mostrando dove si trova il testo che corrisponde al modello.
</testo_normale>
<py_output>
$ python3 re_simple_match.py

Trovato "questo"
in "questo testo ha corrispondenza nel modello?"
da 0 a 6 ("questo")
</py_output>
<titolo_2>
Compilare le Espressioni
</titolo_2>
<testo_normale>
<strong>re</strong> comprende delle funzioni a livello di modulo per lavorare con le espressioni regolari come stringhe di testo, ma in genere è più efficace <em>compilare</em> le espressioni che un proprio programma usa frequentemente. La funzione <code>compile()</code> converte una espressione stringa in un oggetto <code>RegexObject</code>.
</testo_normale>
<py_code>
# re_simple_compiled.py

import re

# Precompile the patterns
regexes = [
    re.compile(p)
    for p in ['questo', 'quello']
]
text = 'questo testo ha corrispondenza nel modello?'

print('Testo: {!r}\n'.format(text))

for regex in regexes:
    print('Ricerca di "{}" ->'.format(regex.pattern), end=' ')

    if regex.search(text):
        print('trovato!')
    else:
        print('non trovato')
</py_code>
<testo_normale>
Le funzioni a livello di modulo mantengono una <a href="https://it.wikipedia.org/wiki/Cache">cache</a> delle espressioni compilate, ma la dimensione della stessa è limitata, e l'usare espressioni compilate direttamente significa che si può evitare il tempo necessario per la ricerca nella cache. Un altro vantaggio è che precompilando tutte le espressioni regolari quando il modulo viene caricato, si ottiene lo spostamento del lavoro di compilazione alla fase di inizializzazione dell'applicazione, invece che in un punto nel quale il programma risponde ad una azione dell'utente.
</testo_normale>
<py_output>
$ python3 re_simple_compiled.py

Testo: 'questo testo ha corrispondenza nel modello?'

Ricerca di "questo" -> trovato!
Ricerca di "quello" -> non trovato
</py_output>
<titolo_2>
Corrispondenze Multiple
</titolo_2>>
<testo_normale>
Fino a qui in tutti i modelli di esempio si è usato <code>search()</code> per cercare singole istanze di stringhe di testo letterali. La funzione <code>findall()</code> restituisce tutte le sottostringhe dell'input che trovano corrispondenza nel modello senza sovrapporsi.
</testo_normale>
<py_code>
# re_findall.py

import re

text = 'abbaaabbbbaaaaa'

pattern = 'ab'

for match in re.findall(pattern, text):
    print('Trovato {!r}'.format(match))
</py_code>
<testo_normale>
Ci sono due istanze di <code>ab</code> nella stringa in input.
</testo_normale>
<py_output>
$ python3 re_findall.py

Trovato 'ab'
Trovato 'ab'
</py_output>
<testo_normale>
<code>finditer()</code> restituisce un iteratore che produce delle istanze di <code>Match</code>  in luogo delle stringhe restituite da <code>findall()$</code>
</testo_normale>
<py_code>
# re_finditer.py

import re

text = 'abbaaabbbbaaaaa'

pattern = 'ab'

for match in re.finditer(pattern, text):
    s = match.start()
    e = match.end()
    print('Trovato {!r} a {:d}:{:d}'.format(
        text[s:e], s, e))
</py_code>
<testo_normale>
In questo esempio si cercano le stesse due occorrenze di <code>ab</code> nella stringa di input.
</testo_normale>
<py_output>
$ python3 re_finditer.py

Trovato 'ab' a 0:2
Trovato 'ab' a 5:7
</py_output>
<titolo_2>
Sintassi del Modello
</titolo_2>>
<testo_normale>
Le espressioni regolari supportano modelli molto più potenti che semplici stringhe letterali di testo. I modelli possono essere ripetuti, possono essere ancorati a diverse locazioni logiche all'interno dell'input e possono essere espressi in forme compatte che non richiedono che ognuno dei caratteri letterali sia presente nel modello. Tutte queste caratteristiche vengono usate per combinare valori di testo letterali con <em>meta-caratteri</em> che sono parte della sintassi dei modelli delle espressioni regolari implementata da <strong>re</strong>.
</testo_normale>
<py_code>
# re_test_patterns.py

import re


def test_patterns(text, patterns=[]):
    """Dato un testo sorgente ed un elenco di modelli, cerca
    corrispondenze per ogni modello all'interno del testo e le
    stampa a stdout
    """
    # Cerca ogni modello nel testo e stampa il risultato
    for pattern, desc in patterns:
        print("'{}' ({})\n".format(pattern, desc))
        print("  '{}'".format(text))
        for match in re.finditer(pattern, text):
            s = match.start()
            e = match.end()
            substr = text[s:e]
            n_backslashes = text[:s].count('\\')
            prefix = '.' * (s + n_backslashes)
            print("  {}'{}'".format(prefix, substr))
        print()
    return

if __name__ == '__main__':
    test_patterns('abbaaabbbbaaaaa',
                  [('ab', "'a' seguito da 'b'"),
                   ])
</py_code>
<testo_normale>
Gli esempi che seguono utilizzano <code>test_patterns()</code> per esplorare come le variazioni nei modelli modificano il modo nel quale viene trovata corrispondenza per lo stesso testo in input. Vengono mostrati il testo di input e la sottostringa da ogni porzione dell'input che corrisponde al modello.
</testo_normale>
<py_output>
$ python3 re_test_patterns.py

'ab' ('a' seguito da 'b')

  'abbaaabbbbaaaaa'
  'ab'
  .....'ab'
</py_output>
<titolo_3>
Ripetizioni
</titolo_3>
<testo_normale>
Ci sono cinque modi per esprimere ripetizione in un modello. Un modello seguito dal metacarattere <code>*</code> viene ripetuto <strong>zero o più</strong> volte (il che significa che il modello può anche non essere presente per costituire una corrispondenza). Con il <em>metacarattere</em> <code>+</code> il modello deve apparire <strong>almeno una</strong> volta. Usando <code>?</code> si desidera che il modello appaia <strong>zero od una volta</strong>. Per uno specifico numero di corrispondenze si usa <code>{m}</code> dopo il modello, dove <em>m</em> viene sostituito dal numero di volte per le quali la corrispondenza col modello dovrebbe ripetersi. Infine, per consentire un numero di ripetizioni variabile, ma limitato, si usa <code>{m,n}</code> dove <em>m</em> è il numero minimo di ripetizioni ed <em>n</em> è quello massimo. Non valorizzare (<em>n</em> <code>{m,}</code>) vuol dire che il valore deve apparire almeno <em>m</em> volte, senza tetto massimo.
</testo_normale>
<py_code>
# re_repetition.py

from re_test_patterns import test_patterns

test_patterns(
    'abbaabbba',
    [('ab*', 'a seguito da zero o più b'),
     ('ab+', 'a seguito da one o più b'),
     ('ab?', 'a seguito da zero od una b'),
     ('ab{3}', 'a seguito da tre b'),
     ('ab{2,3}', 'a seguito da due a tre b')],
)
</py_code>
<testo_normale>
Ci sono più corrispondenze per <code>ab*</code> che per <code>ab+</code>
</testo_normale>
<py_output>
$ python3 re_repetition.py
'ab*' (a seguito da zero o più b)

  'abbaabbba'
  'abb'
  ...'a'
  ....'abbb'
  ........'a'

'ab+' (a seguito da one o più b)

  'abbaabbba'
  'abb'
  ....'abbb'

'ab?' (a seguito da zero od una b)

  'abbaabbba'
  'ab'
  ...'a'
  ....'ab'
  ........'a'

'ab{3}' (a seguito da tre b)

  'abbaabbba'
  ....'abbb'

'ab{2,3}' (a seguito da due a tre b)

  'abbaabbba'
  'abb'
  ....'abbb'
</py_output>
<testo_normale>
Normalmente, quando si elabora una istruzione di ripetizione si consumerà tanto input quanto possibiile mentre si ricerca la corrispondenza del modello. Questo comportamento detto <em>greedy</em> (avido - n.d.t.) potrebbe generare meno corrispondenze individuali, oppure le corrispondenze potrebbero comprendere più testo dall'input di quanto voluto. Questo comportamento può essere disabilitato facendo seguire l'istruzione di ripetizione da <code>?</code>.
</testo_normale>
<py_code>
# re_repetition_non_greedy.py

from re_test_patterns import test_patterns

test_patterns(
    'abbaabbba',
    [('ab*?', 'a seguito da zero o più b'),
     ('ab+?', 'a seguito da one o più b'),
     ('ab??', 'a seguito da zero od una b'),
     ('ab{3}?', 'a seguito da tre b'),
     ('ab{2,3}?', 'a seguito da due fino a tre b')],
)
</py_code>
<testo_normale>
Disabilitando il consumo "avido" dell'ìnput per ognuno dei modelli dove sono consentite zero occorrenze di <code>b</code> fa sì che la stringa per la quale è stata trovata la corrispondenza non comprende alcuna lettera <code>b</code>.
</testo_normale>
<py_output>
$ python3 re_repetition_non_greedy.py
'ab*?' (a seguito da zero o più b)

  'abbaabbba'
  'a'
  ...'a'
  ....'a'
  ........'a'

'ab+?' (a seguito da one o più b)

  'abbaabbba'
  'ab'
  ....'ab'

'ab??' (a seguito da zero od una b)

  'abbaabbba'
  'a'
  ...'a'
  ....'a'
  ........'a'

'ab{3}?' (a seguito da tre b)

  'abbaabbba'
  ....'abbb'

'ab{2,3}?' (a seguito da due fino a tre b)

  'abbaabbba'
  'abb'
  ....'abb'
</py_output>
<titolo_3>
Insiemi di caratteri
</titolo_3>
<testo_normale>
Si tratta di gruppi di caratteri, ognuno dei quali può trovare corrispondenza in quel punto nel modello. Ad esempio <code>[ab]</code> troverebbe corrispondenza con <code>a</code> oppure con <code>b</code>
</testo_normale>
<py_code>
# re_charset.py

from re_test_patterns import test_patterns

test_patterns(
    'abbaabbba',
    [('[ab]', 'sia a che b'),
     ('a[ab]+', 'a seguito da uno o più a oppure b'),
     ('a[ab]+?', 'a seguito da uno o più a oppure b, non greedy')],
)
</py_code>
<testo_normale>
La forma "avida" dell'espressione <code>(a[ab]+)</code> consuma l'intera stringa visto che la prima lettera + una <code>a</code> ed ogni carattere seguente è una <code>a</code> oppure una  <code>b</code>
</testo_normale>
<py_output>
$ python3 re_charset.py

'[ab]' (sia a che b)

  'abbaabbba'
  'a'
  .'b'
  ..'b'
  ...'a'
  ....'a'
  .....'b'
  ......'b'
  .......'b'
  ........'a'

'a[ab]+' (a seguito da uno o piÃ¹ a oppure b)

  'abbaabbba'
  'abbaabbba'

'a[ab]+?' (a seguito da uno o piÃ¹ a oppure b, non greedy)

  'abbaabbba'
  'ab'
  ...'aa'
</py_output>
<testo_normale>
Un insieme di caratteri può anche essere usato per escludere caratteri specifici. L'accento circonflesso (<code>^</code>) vuol dire che bisogna cercare caratteri che non si trovano nell'insieme seguente.
</testo_normale>
<py_code>
# re_charset_exclude.py

from re_test_patterns import test_patterns

test_patterns(
    'Questa è una porzione di testo -- con punteggiatura.',
    [('[^-. ]+', 'sequenze senza -, ., o spazio')],
)
</py_code>
<testo_normale>
Il modello cerca tutte le sottostringhe che non contengono i caratteri <code>-, .</code> o spazio.
</testo_normale>
<py_output>
$ python3 re_charset_exclude.py
'[^-. ]+' (sequenze senza -, ., o spazio)

  'Questa è una porzione di testo -- con punteggiatura.'
  'Questa'
  .......'è'
  .........'una'
  .............'porzione'
  ......................'di'
  .........................'testo'
  ..................................'con'
  ......................................'punteggiatura'
</py_output>
<testo_normale>
Quando l'insieme di caratteri aumenta di dimensione, digitare ciascun carattere per il quale si dovrebbe trovare corrispondenza diventa tedioso. Un formato più compatto può essre utilizzato tramite <em>intervalli di caratteri</em> che possono definire un insieme di caratteri che includa tutti i caratteri contigui fra la partenza ed il punto di arrivo.
</testo_normale>
<py_code>
# re_charset_ranges.py

from re_test_patterns import test_patterns

test_patterns(
    'Questa porzione di testo -- con punteggiatura.',
    [('[a-z]+', 'sequenza di lettere minuscole'),
     ('[A-Z]+', 'sequenza di lettere maiuscole'),
     ('[a-zA-Z]+', 'sequenza di lettere maiuscole o minuscole'),
     ('[A-Z][a-z]+', 'una lettera maiuscola seguita da lettere  minuscole')],
)
</py_code>
<testo_normale>
Qui l'intervallo <code>a-z</code> comprende tutti le lettere minuscole ASCII, e l'intervallo <code>A-Z</code> comprende tutte le lettere maiuscole ASCII. Gli intervalli possono anche essere combinati in un singolo insieme.
</testo_normale>
<py_output>
$ python3 re_charset_ranges.py

'[a-z]+' (sequenza di lettere minuscole)

  'Questa porzione di testo -- con punteggiatura.'
  .'uesta'
  .......'porzione'
  ................'di'
  ...................'testo'
  ............................'con'
  ................................'punteggiatura'

'[A-Z]+' (sequenza di lettere maiuscole)

  'Questa porzione di testo -- con punteggiatura.'
  'Q'

'[a-zA-Z]+' (sequenza di lettere maiuscole o minuscole)

  'Questa porzione di testo -- con punteggiatura.'
  'Questa'
  .......'porzione'
  ................'di'
  ...................'testo'
  ............................'con'
  ................................'punteggiatura'

'[A-Z][a-z]+' (una lettera maiuscola seguita da lettere  minuscole)

  'Questa porzione di testo -- con punteggiatura.'
  'Questa'
</py_output>
<testo_normale>
Un caso speciale di un insieme di caratteri è quello del meta-carattere punto (<code>.</code>), che indica che il modello dovrebbe trovare corripondenza con qualsiasi singolo carattere in quella posizione.
</testo_normale>
<py_code>
# re_charset_dot.py

from re_test_patterns import test_patterns

test_patterns(
    'abbaabbba',
    [('a.', 'a seguito da qualsiasi carattere'),
     ('b.', 'b seguito da qualsiasi carattere'),
     ('a.*b', 'a seguito da qualunque cosa che finisca per b'),
     ('a.*?b', 'a seguito da qualunque cosa, che finisca per b')],
)
</py_code>
<testo_normale>
Combinare il punto con delle ripetizioni potrebbe far trovare corrispondenze piuttosto lunghe, a meno che non si utilizzi la forma "non avida".
</testo_normale>
<py_output>
$ python3 re_charset_dot.py

'a.' (a seguito da qualsiasi carattere)

  'abbaabbba'
  'ab'
  ...'aa'

'b.' (b seguito da qualsiasi carattere)

  'abbaabbba'
  .'bb'
  .....'bb'
  .......'ba'

'a.*b' (a seguito da qualunque cosa che finisca per b)

  'abbaabbba'
  'abbaabbb'

'a.*?b' (a seguito da qualunque cosa, che finisca per b)

  'abbaabbba'
  'ab'
  ...'aab'
</py_output>
<titolo_3>
Codici di escape
</titolo_3>
<testo_normale>
Una ancor più compatta rappresentazione utilizza codici di <em>escape</em> per parecchi insiemi di caratteri predefinti. I codici di <em>escape</em> riconosciuti da <strong>re</strong> sono:
</testo_normale>
<tabella>
Codice;Significato
\d;una cifra
\D;una non cifra
\s;<a href="https://it.wikipedia.org/wiki/Whitespace">whitespace</a>spazio, tabulazione, ritorno a capo ecc
\S;l'opposto di \s
\w;alfanumerico
\W;non alfanumerico
</tabella>
<nota>
I codici di <em>escape</em> sono preferibilmente prefissati dalla barra rovescia (<code>\</code>). Sfortunatamente la barra rovesciata stessa deve essere essa stessa fatta precedere dal codice di <em>escape</em> nelle normali stringhe Python, risultando in una espressione difficile da leggere. L'uso delle stringhe <em>raw</em>, create prefissando il valore letterale con una <code>r</code> elimina il problema e mantiene la leggibilità.
</nota>
<py_code>
# re_escape_codes.py

from re_test_patterns import test_patterns

test_patterns(
    'A prime #1 example!',
    [(r'\d+', 'sequenza di cifre'),
     (r'\D+', 'sequenza di non cifre'),
     (r'\s+', 'sequenza di whitespace'),
     (r'\S+', 'sequenza di non whitespace'),
     (r'\w+', 'caratteri alfanumerici'),
     (r'\W+', 'non alfanumerici')],
)
</py_code>
<testo_normale>
Questa espressione di esempio combina i codici di <code>escape</code> con ripetizioni per trovare le sequenze di detti caratteri nella stringa di input.
</testo_normale>
<py_output>
$ python3 re_escape_codes.py
'\d+' (sequenza di cifre)

  'A prime #1 example!'
  .........'1'

'\D+' (sequenza di non cifre)

  'A prime #1 example!'
  'A prime #'
  ..........' example!'

'\s+' (sequenza di whitespace)

  'A prime #1 example!'
  .' '
  .......' '
  ..........' '

'\S+' (sequenza di non whitespace)

  'A prime #1 example!'
  'A'
  ..'prime'
  ........'#1'
  ...........'example!'

'\w+' (caratteri alfanumerici)

  'A prime #1 example!'
  'A'
  ..'prime'
  .........'1'
  ...........'example'

'\W+' (non alfanumerici)

  'A prime #1 example!'
  .' '
  .......' #'
  ..........' '
  ..................'!'
</py_output>
<testo_normale>
Per trovare corrispondenza con i caratteri che sono parte della sintassi dell'espressione regolare, occorre far precedere ciascun caratteri nel modello di ricerca dal caratttere di <em>escape</em>
</testo_normale>
<py_code>
# re_escape_escapes.py

from re_test_patterns import test_patterns

test_patterns(
    r'\d+ \D+ \s+',
    [(r'\\.\+', 'codice di escape')],
)
</py_code>
<testo_normale>
Il modello in questo esempio utilizza il carattere di <em>escape</em> per la barra rovesciata ed il punto, visto che come meta-caratteri entrambi hanno un significato speciale nell'espressione regolare.
</testo_normale>
<py_output>
$ python3 re_escape_escapes.py

'\\.\+' (codice di escape)

  '\d+ \D+ \s+'
  '\d+'
  .....'\D+'
  ..........'\s+'
</py_output>
<titolo_3>
Ancoraggio
</titolo_3>
<testo_normale>
Oltrae a descrivere il contenuto del modello per il quale trovare corrispondenza, è possibile specificare anche la posizione relativa nel testo di input laddove il modello dovrebbe apparire utilizzando istruzioni di <em>ancoraggio</em>; la tabella seguente mostra i codici di ancoraggio utilzzabili.
</testo_normale>
<tabella>
Codice;Significato
^;inizio della stringa o della riga
$;fine della stringa o della riga
\A;inizio della stringa
\Z;fine della stringa
\b;stringa vuota all'inizio o fine di una parola
\B;stringa vuota non all'inizio o fine di una parola
</tabella>
<py_code>
# re_anchoring.py

from re_test_patterns import test_patterns

test_patterns(
    'Trova in parte di testo -- con punteggiatura.',
    [(r'^\w+', 'parola ad inizio stringa'),
     (r'\A\w+', 'parola ad inizio stringa'),
     (r'\w+\S*$', 'parola verso la fine della stringa, senza punteggiatura'),
     (r'\w+\S*\Z', 'parola verso la fine della stringa, senza punteggiatura'),
     (r'\w*t\w*', 'parola che contiene t'),
     (r'\bt\w+', 't ad inizio della parola'),
     (r'\w+t\b', 't alla fine della parola'),
     (r'\Bt\B', 't, non all\'inizio o fine della parola')],
)
</py_code>
<testo_normale>
I modelli nell'esempio per cercare parole all'inizio e fine della stringa sono diversi poichè la parola alla fine della stringa è seguita da un simbolo di punteggiatura che termina la frase. Il modello <code>\W+$</code> non troverebbe corrispondenza, visto che <code>.</code> non viene considerato come carattere alfanumerico.
</testo_normale>
<py_output>
$ python3 re_anchoring.py
'^\w+' (parola ad inizio stringa)

  'Trova in parte di testo -- con punteggiatura.'
  'Trova'

'\A\w+' (parola ad inizio stringa)

  'Trova in parte di testo -- con punteggiatura.'
  'Trova'

'\w+\S*$' (parola verso la fine della stringa, senza punteggiatura)

  'Trova in parte di testo -- con punteggiatura.'
  ...............................'punteggiatura.'

'\w+\S*\Z' (parola verso la fine della stringa, senza punteggiatura)

  'Trova in parte di testo -- con punteggiatura.'
  ...............................'punteggiatura.'

'\w*t\w*' (parola che contiene t)

  'Trova in parte di testo -- con punteggiatura.'
  .........'parte'
  ..................'testo'
  ...............................'punteggiatura'

'\bt\w+' (t ad inizio della parola)

  'Trova in parte di testo -- con punteggiatura.'
  ..................'testo'

'\w+t\b' (t alla fine della parola)

  'Trova in parte di testo -- con punteggiatura.'
  ..................'testo'

'\Bt\B' (t, non all'inizio o fine della parola)

  'Trova in parte di testo -- con punteggiatura.'
  ............'t'
  .....................'t'
  ..................................'t'
  ........................................'t'
</py_output>
<titolo_2>
Limitare la ricerca
</titolo_2>
<testo_normale>
Ci sono situazioni laddove si conosce in anticipo che si dovrebbe eseguire la ricreca solo in un sotto insieme dell'input, le regole di corrispondenza dell'espressione regolare possono essere ulteriormente limitate dicendo a <strong>re</strong> di confinare il raggio di ricerca. Ad esempio, se il modello deve trovarsi all'inizio dell'input, usando <code>match()</code> invece che <code>search()</code> si ancora la ricerca senza dover includere esplicitamente un ancoraggio nel modello di ricerca
</testo_normale>
<py_code>
# re_match.py

import re

text = 'Questa è una porzione di testo -- con punteggiatura.'
pattern = 'te'

print('Testo   :', text)
print('Modello :', pattern)

m = re.match(pattern, text)
print('Match  :', m)
s = re.search(pattern, text)
print('Search :', s)
</py_code>
<testo_normale>
Visto che &quot;te&quot; non si trova all'inizio della stringa in input, non viene trovato utilizzando <code>match()</code>. Visto che la parola compare altre due volte nella string, <code>search()</code> la trova
</testo_normale>
<py_output>
$ python3 re_match.py

Testo   : Questa è una porzione di testo -- con punteggiatura.
Modello : te
Match  : None
Search : <_sre.SRE_Match object; span=(25, 27), match='te'>
</py_output>
<testo_normale>
Il metodo <code>fullmatch()</code> richiede che l'intera stringa trovi corrispondenza con il modello
</testo_normale>
<py_code>
# re_fullmatch.py

import re

text = 'Questa è una porzione di testo -- con punteggiatura.'
pattern = 'te'

print('Testo      :', text)
print('Modello    :', pattern)

m = re.search(pattern, text)
print('Search     :', m)
s = re.fullmatch(pattern, text)
print('Full match :', s)
</py_code>
<testo_normale>
In questo caso <code>search()</code> mostra che il modello appare nell'input, ma non consuma tutto l'input, quindi <code>fullmatch()</code> non riporta una corrispondenza.
</testo_normale>
<py_output>
$ python3 re_fullmatch.py

Testo      : Questa è una porzione di testo -- con punteggiatura.
Modello    : te
Search     : <_sre.SRE_Match object; span=(25, 27), match='te'>
Full match : None
</py_output>
<testo_normale>
Il metodo <code>search()</code> in una espressione regolare compilata accetta i parametri opzionali <em>start</em> e <em>end</em> come posizione di partenza ed arrivo per limitare la ricerca ad una porzione di testo.
</testo_normale>
<py_code>
# re_search_substring.py

import re

text = 'Questa è una porzione di testo -- con punteggiatura.'
pattern = re.compile(r'\b\w*te\w*\b')

print('Testo:', text)
print()

pos = 0
while True:
    match = pattern.search(text, pos)
    if not match:
        break
    s = match.start()
    e = match.end()
    print('  {:>2d} : {:>2d} = "{}"'.format(
        s, e - 1, text[s:e]))
    # Si sposta in avanti nel testo per la ricerca successiva
    pos = e
</py_code>
<testo_normale>
Questo esempio impolementa una forma meno efficiente di <code>iterall()</code>. Ogni volta che viene trovata una corrispondenza, la posizione di fine di quella corrispondenza viene utilizzata per la ricerca successiva.
</testo_normale>
<py_output>
$ python3 re_search_substring.py

Testo: Questa è una porzione di testo -- con punteggiatura.

  25 : 29 = "testo"
  38 : 50 = "punteggiatura"
</py_output>
<titolo_2>
Scorporare le Corrispondenze con i Gruppi
</titolo_2>
<testo_normale>
Cercare la corrispondenza di modelli è alla base delle potenti capacità fornite dalle espressioni regolari. Aggiungere gruppi ad un modello consente di isolare parti del testo corrisposto, espandendo queste capactità per creare un <a href="https://it.wikipedia.org/wiki/Parsing">parser</a>. I gruppi sono definiti includendo tra parentesi i modelli ((e)).
</testo_normale>
<py_code>
# re_groups.py

from re_test_patterns import test_patterns

test_patterns(
    'abbaaabbbbaaaaa',
    [('a(ab)', 'a seguito da ab letterale'),
     ('a(a*b*)', 'a seguito da 0-n a e 0-n b'),
     ('a(ab)*', 'a seguito da 0-n ab'),
     ('a(ab)+', 'a seguito da 1-n ab')],
)
</py_code>
<testo_normale>
Qualsiasi espressione regolare completa può essere convertita in un gruppo ed annidata in una espressione più grande. Tutti i modificatori di ripetizione possono essere applicati ad un gruppo come insieme, facendo sì che venga ripetuto l'intero gruppo del modello.
</testo_normale>
<py_output>
$ python3 re_groups.py

'a(ab)' (a seguito da ab letterale)

  'abbaaabbbbaaaaa'
  ....'aab'

'a(a*b*)' (a seguito da 0-n a e 0-n b)

  'abbaaabbbbaaaaa'
  'abb'
  ...'aaabbbb'
  ..........'aaaaa'

'a(ab)*' (a seguito da 0-n ab)

  'abbaaabbbbaaaaa'
  'a'
  ...'a'
  ....'aab'
  ..........'a'
  ...........'a'
  ............'a'
  .............'a'
  ..............'a'

'a(ab)+' (a seguito da 1-n ab)

  'abbaaabbbbaaaaa'
  ....'aab'
</py_output>
<testo_normale>
Per accedere alle sottostringhe dei singoli gruppi all'interno di un modello si usa il metodo <code>groups()</code> dell'oggetto <code>Match</code>.
</testo_normale>
<py_code>
# re_groups_match.py

import re

text = 'Questa è una porzione di testo -- con punteggiatura.'
print(text)
print()

patterns = [
    (r'^(\w+)', 'parola ad inizio stringa'),
    (r'(\w+)\S*$', 'parola alla fine, with punteggiatura opzionale'),
    (r'(\bt\w+)\W+(\w+)', 'parola che inizia con t, poi un\'altra parola'),
    (r'(\w+o)\b', 'parola che finisce con o'),
]

for pattern, desc in patterns:
    regex = re.compile(pattern)
    match = regex.search(text)
    print("'{}' ({})\n".format(pattern, desc))
    print('  ', match.groups())
    print()
</py_code>
<testo_normale>
<code>Match.groups()</code> ritorna una sequenza di stringhe in base all'ordine dei gruppi all'interno dell'espressione che trova corrispondenza nella stringa.
</testo_normale>
<py_output>
$ python3 re_groups_match.py

Questa è una porzione di testo -- con punteggiatura.

'^(\w+)' (parola ad inizio stringa)

   ('Questa',)

'(\w+)\S*$' (parola alla fine, with punteggiatura opzionale)

   ('punteggiatura',)

'(\bt\w+)\W+(\w+)' (parola che inizia con t, poi un'altra parola)

   ('testo', 'con')

'(\w+o)\b' (parola che finisce con o)

   ('testo',)
</py_output>
<testo_normale>
Per la corrispondenza con un singolo gruppo si usa <code>group()</code>. Utile quando il raggruppamento viene usato per trovare parti della stringa, ma alcune parti per le quali è stata trovata corrispondenza dei gruppi non sono necessarie nel risultato.
</testo_normale>
<py_code>
# re_groups_individual.py

import re

text = 'Questa è una porzione di testo -- con punteggiatura.'

print('Testo in input              :', text)

# parola che inizia con 't, poi un'altra parola
regex = re.compile(r'(\bt\w+)\W+(\w+)')
print ('Modello di corrispondenza   :', regex.pattern)

match = regex.search(text)
print('Intera corrispondenza       :', match.group(0))
print('Parola inizia con  "t"      :', match.group(1))
print('Parola dopo la parola con"t":', match.group(2))
</py_code>
<testo_normale>
Il gruppo <code>0</code> rappresenta la stringa che corrisponde all'intera espressione, ed i sotto gruppi sono numerati a partire da 1 nell'ordine nel quale la loro parentesi sinistra compare nell'espressione.
</testo_normale>
<py_output>
$ python3 re_groups_individual.py

Testo in input              : Questa Ã¨ una porzione di testo -- con punteggiatura.
Modello di corrispondenza   : (\bt\w+)\W+(\w+)
Intera corrispondenza       : testo -- con
Parola inizia con  "t"      : testo
Parola dopo la parola con"t": con
</py_output>
<testo_normale>
Python estende la sintassi base per il raggruppamento aggiungendo gruppi <em>nominali</em>. Utilizzare nome per riferirsi a gruppi facilita la modifica del modello nel tempo, senza dovere modificare anche il codice che utilizza il risultato della corrispondenza. Per impostare il nome di un gruppo la sintassi è <code>(?P<name>pattern)</code>
</testo_normale>
<py_code>
# re_groups_named.py

import re

text = 'Questa è una porzione di testo -- con punteggiatura.'

print(text)
print()

patterns = [
    r'^(?P<prima_parola>\w+)',
    r'(?P<ultima_parola>\w+)\S*$',
    r'(?P<parola_t>\bt\w+)\W+(?P<altra_parola>\w+)',
    r'(?P<finisce_con_o>\w+o)\b',
]

for pattern in patterns:
    regex = re.compile(pattern)
    match = regex.search(text)
    print("'{}'".format(pattern))
    print('  ', match.groups())
    print('  ', match.groupdict())
    print()

</py_code>
<testo_normale>
Si usa <code>groupdict()</code> per recuperare il dizionario di mappatura dei nomi dei gruppi. I gruppi nominali sono inclusi anche nella sequenza ordinata ritornata da <code>groups()</code>.
</testo_normale>
<py_output>
$ python3 re_groups_named.py

Questa è una porzione di testo -- con punteggiatura.

'^(?P<prima_parola>\w+)'
   ('Questa',)
   {'prima_parola': 'Questa'}

'(?P<ultima_parola>\w+)\S*$'
   ('punteggiatura',)
   {'ultima_parola': 'punteggiatura'}

'(?P<parola_t>\bt\w+)\W+(?P<altra_parola>\w+)'
   ('testo', 'con')
   {'parola_t': 'testo', 'altra_parola': 'con'}

'(?P<finisce_con_o>\w+o)\b'
   ('testo',)
   {'finisce_con_o': 'testo'}
</py_output>
<testo_normale>
Una versione aggiornata di <code>test_patterns()</code> che mostra i gruppi numerati e nominali corrisposti nel modello renderà gli esempi seguenti più facili da seguire.
</testo_normale>
<py_code>
# re_test_patterns_groups.py

import re

def test_patterns(text, patterns=[]):
    """Dato un testo sorgente ed un elenco di modelli
    cerca corrispondenze per ogni modello all'interno del testo
    e le stampa su stdout.
    """
    # Cerca ciascun modello nel testo e stampa i risultati
    for pattern, desc in patterns:
        print('{!r} ({})\n'.format(pattern, desc))
        print('  {!r}'.format(text))
        for match in re.finditer(pattern, text):
            s = match.start()
            e = match.end()
            prefix = ' ' * (s)
            print(
                '  {}{!r}{} '.format(prefix,
                                     text[s:e],
                                     ' ' * (len(text) - e)),
                end=' ',
            )
            print(match.groups())
            if match.groupdict():
                print('{}{}'.format(
                    ' ' * (len(text) - s),
                    match.groupdict()),
                )
        print()
    return
</py_code>
<testo_normale>
Visto che un gruppo è di per se una espressione regolare completa, i gruppi possono essere annidati all'interno di altri per costruire espressioni regolari ancor più complicate.
</testo_normale>
<py_code>
# re_groups_nested.py

from re_test_patterns_groups import test_patterns

test_patterns(
    'abbaabbba',
    [(r'a((a*)(b*))', 'a followed by 0-n a and 0-n b')],
)
</py_code>
<testo_normale>
In questo caso, il gruppo <code>(a*)</code> trova corrispondenza con una stringa vuota, quindi il valore di ritorno da <code>groups()</code> include anche una stringa vuota nel valore corrisposto.
</testo_normale>
<py_output>
$ python3 re_groups_nested.py
'a((a*)(b*))' (a followed by 0-n a and 0-n b)

  'abbaabbba'
  'abb'        ('bb', '', 'bb')
     'aabbb'   ('abbb', 'a', 'bbb')
          'a'  ('', '', '')
</py_output>
<testo_normale>
I gruppi sono anche utili per specificare modelli alternativi. Si usa il simbolo <em>pipi</em> (<code>|</code>) per indicare che si dovrebbe cercare corrispondenza con un modello o con un altro. Occorre tuttavia considerare il piazzamento del <em>pipe</em> con cautela. La prima espressione in questo esempio cerca trova corrispondenza con una sequenza di <em>a</em> seguito da una sequenza costituita interamente da una singola lettera: <em>a</em> o <em>b</em>. Il secondo modello trovacorrispondenza con una <em>a</em> seguita da una sequenza che potrebbe includere <strong>sia</strong> <em>a</em> che <em>b</em>. I modelli sono simili ma le corrispondenze risultanti sono completamente differenti.
</testo_normale>
<py_code>
# re_groups_alternative.py

from re_test_patterns_groups import test_patterns

test_patterns(
    'abbaabbba',
    [(r'a((a+)|(b+))', 'a then seq. of a or seq. of b'),
     (r'a((a|b)+)', 'a then seq. of [ab]')],
)
</py_code>
<testo_normale>
Quando non si trova corrispondenza con un gruppo alternativo, ma si ha corrispondenza con l'intero modello, il valore di ritorno di <code>groups()</code> include un valore <code>None</code> nel punto nella sequenza nella quale dovrebbe comparire il gruppo alternativo.
</testo_normale>
<py_output>
$ python3 re_groups_alternative.py

'a((a+)|(b+))' (a then seq. of a or seq. of b)

  'abbaabbba'
  'abb'        ('bb', None, 'bb')
     'aa'      ('a', 'a', None)

'a((a|b)+)' (a then seq. of [ab])

  'abbaabbba'
  'abbaabbba'  ('bbaabbba', 'a')
</py_output>
<testo_normale>
Definire un gruppo che contiene un sotto-modello è anche utile nei casi dove la stringa che trova corrispondenza nel sotto-modello non è parte di ciò che dovrebbe essere estratto dal testo completo. Questi gruppi sono detti <em>non catturanti</em>. I gruppi <em>non catturanti</ em> possono essere usati per descrivere modelli ripetitivi od alternativi, senza isolare la pozione della stringa corrisposta nel valore ritornato. Per creare un gruppo <em>non catturante</em> si usa la sintassi <code>(?:modello)</code>.
</testo_normale>
<py_code>
# re_groups_noncapturing.py

from re_test_patterns_groups import test_patterns

test_patterns(
    'abbaabbba',
    [(r'a((a+)|(b+))', 'capturing form'),
     (r'a((?:a+)|(?:b+))', 'noncapturing')],
)
</py_code>
<testo_normale>
Confronta i gruppi ritornati dalle forme <em>catturanti</em> e <em>non catturanti</em> di un modello che trova corrispondenza con gli stessi risultati.
</testo_normale>
<py_output>
$ python3 re_groups_noncapturing.py

'a((a+)|(b+))' (capturing form)

  'abbaabbba'
  'abb'        ('bb', None, 'bb')
     'aa'      ('a', 'a', None)

'a((?:a+)|(?:b+))' (noncapturing)

  'abbaabbba'
  'abb'        ('bb',)
     'aa'      ('a',)
</py_output>
<titolo_2>
Opzioni di Ricerca
</titolo_2>
<testo_normale>
Il modo nel quale il motore di corrispondenza processa una espressione può essere modificato utilizzando flag di opzione. I flag possono essere combinati utilzzando una <a href="https://it.wikipedia.org/wiki/Operazione_bit_a_bit">operazione bit a bit</a> di tipo <em>or</em>, poi passti a <code>compile()</code>, <code>search()</code>, <code>match()</code>, ed altre funzioni cha accettano un modello per una ricerca.
</testo_normale>
<titolo_3>
Corrispondenza Non Sensibile alle Maiuscole (case-insensitive)
</titolo_3>
<testo_normale>
<code>IGNORECASE</code> fa sì che i caratteri letterali ed i gruppi di caratteri nel modello siano ricercati sia come caratteri maiuscoli e minuscoli (case-insensitive)
</testo_normale>
<py_code>
# re_flags_ignorecase.py

import re

text = 'Test su di una porzione di testo -- con punteggiatura.'
pattern = r'\bT\w+'
with_case = re.compile(pattern)
without_case = re.compile(pattern, re.IGNORECASE)

print('Testo:\n  {!r}'.format(text))
print('Modello:\n  {}'.format(pattern))
print('Case-sensitive:')
for match in with_case.findall(text):
    print('  {!r}'.format(match))
print('Case-insensitive:')
for match in without_case.findall(text):
    print('  {!r}'.format(match))

</py_code>
<testo_normale>
Visto che il modello include la lettera <code>T</code>, senza impostare <code>IGNORECASE</code> la sola corrispondenza è con la parola <code>Test</code>. Quando la distinzione maiuscolo/minuscolo è ignorata si ha corrispondenza anche con <code>testo</code>
</testo_normale>
<py_output>
$ python3 re_flags_ignorecase.py

Testo:
  'Test su di una porzione di testo -- con punteggiatura.'
Modello:
  \bT\w+
Case-sensitive:
  'Test'
Case-insensitive:
  'Test'
  'testo'
</py_output>
<titolo_3>
Input su Righe Multiple
</titolo_3>
<testo_normale>
Ci sono due flag che influenzano il modo di ricerca su di un input multiriga: <code>MULTILINE</code> e <code>DOTALL</code>. Il flag <code>MULTILINE</code> controlla come il codice del modello di corrispondenza elabora le istruzioni di ancoraggio per testo che contiene caratteri di ritorno a capo. Quando la modalità multiriga è attivata, le regole di ancoraggio per <code>^</code> e <code>$</code> si applicano all'inizio ed alla fine di ciascuna riga, oltre all'intera stringa.
</testo_normale>
<py_code>
# re_flags_multiline.py

import re

text = 'Test su di una porzione di testo -- con punteggiatura.\nUn\'altra riga.'
pattern = r'(^\w+)|(\w+\S*$)'
single_line = re.compile(pattern)
multiline = re.compile(pattern, re.MULTILINE)

print('Testo:\n  {!r}'.format(text))
print('Modello:\n  {}'.format(pattern))
print('Riga Singola :')
for match in single_line.findall(text):
    print('  {!r}'.format(match))
print('Multiriga    :')
for match in multiline.findall(text):
    print('  {!r}'.format(match))
</py_code>
<testo_normale>
Il modello nell'esempio trova corrispondenza con la prima o l'ultima parola dell'input. Trova <code>riga.</code> alla fine della stringa anche se non c'è un ritorno a capo
</testo_normale>
<py_output>
$ python3 re_flags_multiline.py

Testo:
  "Test su di una porzione di testo -- con punteggiatura.\nUn'altra riga."
Modello:
  (^\w+)|(\w+\S*$)
Riga Singola :
  ('Test', '')
  ('', 'riga.')
Multiriga    :
  ('Test', '')
  ('', 'punteggiatura.')
  ('Un', '')
  ('', 'riga.')
</py_output>
<testo_normale>
<code>DOTALL</code> è l'altro flag legato al testo multiriga. Normalmente il punto (<code>.</code>) trova corrispondenza con tutto il testo nell'input tranne un carattere di ritorno a capo. Il flag consente al punto di includere anche il ritorno a capo per la ricerca di corrispondenza.
</testo_normale>
<py_code>
# re_flags_dotall.py

import re

text = 'Test su di una porzione di testo -- con punteggiatura.\nUn\'altra riga.'
pattern = r'.+'
no_newlines = re.compile(pattern)
dotall = re.compile(pattern, re.DOTALL)

print('Testo:\n  {!r}'.format(text))
print('Modello:\n  {}'.format(pattern))
print('No ritorni a capo :')
for match in no_newlines.findall(text):
    print('  {!r}'.format(match))
print('Dotall      :')
for match in dotall.findall(text):
    print('  {!r}'.format(match))
</py_code>
<testo_normale>
Senza il flag, ciascuna riga del testo in input trova corrispondenza separatamente. L'aggiunta del flag fa sì che venga consumata l'intera stringa.
</testo_normale>
<py_output>
$ python3 re_flags_dotall.py

Testo:
  "Test su di una porzione di testo -- con punteggiatura.\nUn'altra riga."
Modello:
  .+
No ritorni a capo :
  'Test su di una porzione di testo -- con punteggiatura.'
  "Un'altra riga."
Dotall      :
  "Test su di una porzione di testo -- con punteggiatura.\nUn'altra riga."
</py_output>
<vedi_anche>
http://docs.python.org/3.5/library/fnmatch.html|fnmatch|La documentazione della libreria standard per questo modulo.
glob.html|glob|Il modulo <strong>glob</strong> combina le capacità di corrispondenza di <strong>fnmatch</strong> con <code>os.listdir()</code> per produrre elenchi di modelli di confonto per file e directory
</vedi_anche>
</documento_tradotto>
</testo_normale>
