<?xml version="1.0" encoding="Latin-1"?>
<categoria>Concomitanze con Processi, Thread e Coroutine</categoria><!-- # tag <descrizione> contiene le voci per la tabella di riepilogo iniziale -->
<!-- # tag <titolo_1> titolo principale -->
<!-- # tag <titolo_1> titolo principale -->
<!-- tag <testo_normale> contiene il testo normale dell'articolo -->
<!-- tag <titolo_2> contiene il testo per l'intestazione di un paragrafo -->
<!-- tag <py_code> contiene il testo che rappresenta delle istruzioni python -->
<!-- tag <py_output> contiene il testo che rappresenta l'outpuy di uno script python -->
<!-- tag <vedi_anche> contiene il testo che rappresentano i riferimenti esterni -->
<documento_tradotto>
<titolo_1>
subprocess - Genera Processi Addizionali
</titolo_1>
<descrizione>
Fa partire e comunica con processi addizionali

</descrizione>
<testo_normale>
Il modulo <strong>subprocess</strong> supporta 3 <a href='https://it.wikipedia.org/wiki/Application_programming_interface' target='_blank'>API</a> per lavorare con processi. La funzione <code>run()</code>, aggiunte in Python 3.5 è una <a href='https://it.wikipedia.org/wiki/Application_programming_interface' target='_blank'>API</a> ad alto livello per eseguire un processo con opzione di catturare il suo output. Le funzioni <code>call()</code>, <code>check_call()</code>, e <code>check_output()</code> sono tre precedenti <a href='https://it.wikipedia.org/wiki/Application_programming_interface' target='_blank'>API</a> di alto livello, portate dalla versione 2 di Python. Esse sono ancora supportate e largamente usate in programmi esistenti. La classe <code>Popen</code>
è una <a href='https://it.wikipedia.org/wiki/Application_programming_interface' target='_blank'>API</a> di basso livello usata per costruire le altr  <a href='https://it.wikipedia.org/wiki/Application_programming_interface' target='_blank'>API</a> ed utile per interazioni più complesse con i processi. Il  costruttore per <code>Popen</code> riceve argomenti per impostare il nuovo processo in modo che il genitore possa comunicare con esso tramite <a href='https://www.wikiwand.com/it/Pipe_(informatica)' target='_blank'>pipe</a>. Fornisce tutte le funzionalità degli altri moduli e funzioni che rimpiazza, ed altro ancora. L'<a href='https://it.wikipedia.org/wiki/Application_programming_interface' target='_blank'>API</a> è consistente per tutti gli utilizzi, e molti dei passi supplementari necessari (tipo la chiusura di descrittori di file extra e l'assicurare che le <a href='https://www.wikiwand.com/it/Pipe_(informatica)' target='_blank'>pipe</a> siano chiuse) sono "incorporte" invece che essere gestite dal codice dell'applicazione separatamente.
</testo_normale>
<testo_normale>
Il modulo <strong>subprocess</strong> è concepito per sostituire funzioni tipo <code>os.system()</code>, <code>os.spawn()</code>, le varianti di <code>popen()</code> nei moduli <a href='os.html'>os</a> e popen2, così come il modulo commands. Per facilitare il confronto di <strong>subprocess</strong> con questi altri moduli, molti degli esempi di questa sezione ricreano quelli usati per <a href='os.html'>os</a> e popen2
</testo_normale>
<note>
L'<a href='https://it.wikipedia.org/wiki/Application_programming_interface' target='_blank'>API</a> per lavorare con Unix e Windows è grossomodo la stessa, ma l'implementazione sottostante è leggermente diversa a causa della differenza nei modelli di processo nei sistemi operativi. Tutti gli esempi qui mostrati  sono testati su MAC Os X. L'esperienza personale in un sistema operativo diverso da Unix potrebbe essere diversa.
</note>
<titolo_2>
Eseguire comandi esterni
</titolo_2>
<testo_normale>
Per eseguire un comando esterno senza interagire con esso, proprio come si farebbe con <em>os.system()</em>, si usa la funzione <code>run()</code>
</testo_normale>
<py_code>
# subprocess_os_system.py

import subprocess

completed = subprocess.run(['ls', '-1'])
print('codice_di_ritorno:', completed.returncode)
</py_code>
<testo_normale>
Gli argomenti di riga di comando sono passati come lista di stringhe, che consente di evitare l'<em>escape</em> di apici od altri caratteri speciali che potrebbero essere interpretati dalla <a href='https://www.wikiwand.com/it/Shell_(informatica)' target='_blank'>shell</a>. <code>run()</code> ritorna una istanza di <code>CompletedProcess</code> con informazioni circa il processo tipo il codice di uscita e l'output.
</testo_normale>
<py_output>
$ python3 subprocess_os_system.py

index.rst
interaction.py
repeater.py
signal_child.py
signal_parent.py
subprocess_check_output_error_trap_output.py
subprocess_os_system.py
subprocess_pipes.py
subprocess_popen2.py
subprocess_popen3.py
subprocess_popen4.py
subprocess_popen_read.py
subprocess_popen_write.py
subprocess_run_check.py
subprocess_run_output.py
subprocess_run_output_error.py
subprocess_run_output_error_suppress.py
subprocess_run_output_error_trap.py
subprocess_shell_variables.py
subprocess_signal_parent_shell.py
subprocess_signal_setpgrp.py
codice_di_ritorno: 0
</py_output>
<testo_normale>
Impostando l'argomento <a href='https://www.wikiwand.com/it/Shell_(informatica)' target='_blank'>shell</a>Quando <em>shell</em>  a <code>True</code>, fa sì che <strong>subprocess</strong> generi un processo intermedio di <a href='https://www.wikiwand.com/it/Shell_(informatica)' target='_blank'>shell</a> dalla quale viene eseguito il comando. La modalità predefinita è di eseguire il comando direttamente.
</testo_normale>
<py_code>
# subprocess_shell_variables.py

import subprocess

completed = subprocess.run('echo $HOME', shell=True)
print('returncode:', completed.returncode)
</py_code>
<testo_normale>
Usando una <a href='https://www.wikiwand.com/it/Shell_(informatica)' target='_blank'>shell</a> intermedia implica che le variabili i modelli glob altre caratteristiche speciali della <a href='https://www.wikiwand.com/it/Shell_(informatica)' target='_blank'>shell</a> nella riga di comando sono elaborate prima che il comando venga eseguito.
</testo_normale>
<py_output>
$ python3 subprocess_shell_variables.py

/home/robby
returncode: 0
</py_output>


<py_code>
# import subprocess

# Comando con espansione della shell
subprocess.call('ls -1 $HOME', shell=True)
</py_code>
<note>
Usando <code>run()</code> senza passare <code>check=True</code> equivale alla chiamata di  <code>call()</code>, che restituisce solo il codice di uscita dal processo.
</note>
<titolo_3>
Gestione degli Errori
</titolo_3>
<testo_normale>
L'attributo <code>returncode</code> di <code>CompletedProcess</code> è il codice di uscita del programma. Il chiamante è responsabile dell'interpretazione per rilevare errori. Se l'argomento <code>check</code> di <code>run()</code> è <code>True</code>, il codice di uscita viene verificato e, qualora indichi che un errore si è verificato, viene sollevata l'eccezione <code>CalledProcessError</code>.
</testo_normale>
<py_code>
# subprocess_run_check.py

import subprocess

try:
    subprocess.run(['false'], check=True)
except subprocess.CalledProcessError as err:
    print('ERRORE:', err)
</py_code>
<testo_normale>
Il comando <code>false</code> esce sempre con un codice di stato diverso da zero, che viene interpretato da <code>run()</code> come un errore
</testo_normale>
<py_output>
$ python3 subprocess_run_check.py

ERRORE: Command '['false']' returned non-zero exit status 1
</py_output>
<note>
Passando <code>check=True</code> a <code>run()</code> equivale alla chiamata di <code>check_call()</code>.
</note>
<titolo_3>
Catturare Output
</titolo_3>
<testo_normale>
I canali standard di input ed output per il processo fatto partire da <code>run()</code> sono legati all'input ed output del genitore. Il che significa che il programma chiamante non può catturare l'output del comando. Si passi <code>PIPE</code> per gli argomenti di <code>stdout</code> e <code>stderror</code> per catturare l'output per una successiva elaborazione.
</testo_normale>
<py_code>
# subprocess_run_output.py

import subprocess

completed = subprocess.run(
    ['ls', '-1', '/home/robby/test'],
    stdout=subprocess.PIPE,
)
print('returncode:', completed.returncode)
print('Ci sono {} byte in stdout:\n{}'.format(
    len(completed.stdout),
    completed.stdout.decode('utf-8'))
)
</py_code>
<testo_normale>
Il comando <code>ls -1 /home/robby/test</code> viene eseguito con successo, quindi il testo che stampa  verso l'output standard viene catturate e restituito
</testo_normale>
<py_output>
$ python3 subprocess_run_output.py

returncode: 0
Ci sono 299 byte in stdout:
subprocess_os_system.py
subprocess_pipes.py
subprocess_popen2.py
subprocess_popen3.py
subprocess_popen4.py
subprocess_popen_read.py
subprocess_popen_write.py
subprocess_run_check.py
subprocess_run_output.py
subprocess_shell_variables.py
subprocess_signal_parent_shell.py
subprocess_signal_setsid.py
</py_output>
<note>
Passare <code>check=True</code> ed impostando <code>stdout</code> a <code>PIPE</code> equivale ad usare <code>check_output</code>.
<testo_normale>
L'esempio successivo esegue una serie di comandi in una sub-shell. I messaggi sono inviati allo standard output ed allo standard error prima che i comandi escano con un codice di errore
</testo_normale>
<py_code>

</py_code>
<testo_normale>
Il messaggio allo standard error viene stampato sulla console, ma il messaggio verso lo standard output viene nascosto.
</testo_normale>
<py_output>
$ python3 subprocess_run_output_error.py
to stderr
ERRORE: Command 'echo to stdout; echo to stderr 1>&2; exit 1' returned non-zero exit status 1
</py_output>
<testo_normale>
Per evitare la scrittura sulla console di messaggi di errore dai comandi eseguiti tramite <code>run()</code>, si imposti il parametro <code>stderr</code> alla costante <code>PIPE</code>
</testo_normale>
<py_code>
# subprocess_run_output_error_trap.py

import subprocess

try:
    completed = subprocess.run(
        'echo to stdout; echo to stderr 1>&2; exit 1',
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
except subprocess.CalledProcessError as err:
    print('ERRORE:', err)
else:
    print('returncode:', completed.returncode)
    print('Ci sono {} byte in stdout: {!r}'.format(
        len(completed.stdout),
        completed.stdout.decode('utf-8'))
    )
    print('Ci sono {} byte in stderr: {!r}'.format(
        len(completed.stderr),
        completed.stderr.decode('utf-8'))
    )
</py_code>
<testo_normale>
Questo esempio non imposta <code>check=True</code> in mode che l'output del comando venga catturato e stampato.
</testo_normale>
<py_output>
$ python3 subprocess_run_output_error_trap.py

returncode: 1
Ci sono 10 byte in stdout: 'to stdout\n'
Ci sono 10 byte in stderr: 'to stderr\n'
</py_output>
<testo_normale>
Per catturare i messaggi di errore quanto si usa <code>check_output()</code>, si imposta <code>stderr</code> a <code>STDOUT</code>, ed i messaggi saranno combinati con il resto dell'output dal comando.
</testo_normale>
<py_code>
# subprocess_check_output_error_trap_output.py

import subprocess

try:
    output = subprocess.check_output(
        'echo to stdout; echo to stderr 1>&2',
        shell=True,
        stderr=subprocess.STDOUT,
    )
except subprocess.CalledProcessError as err:
    print('ERRORE:', err)
else:
    print('Ci sono {} byte in output: {!r}'.format(
        len(output),
        output.decode('utf-8'))
    )
</py_code>
<testo_normale>
L'ordine nell'output può variare a seconda di come venga applicato il <a href='https://www.wikiwand.com/it/Buffer' target='_blank'>buffering</a> al canale standard output e di quanti dati siano stampati.
</testo_normale>
<py_output>
$ python3 subprocess_check_output_error_trap_output.py

Ci sono 20 byte in output: 'to stdout\nto stderr\n'
</py_output>
<titolo_3>
Sopprimere l'Output
</titolo_3>
<testo_normale>
Nei casi dove l'output non dovrebbe essere mostrato o catturato, si usi <code>DEVNULL</code> per sopprimre il canale di output. Questo esempio sopprime i canali di standard error ed output
</testo_normale>
<py_code>
# subprocess_run_output_error_suppress.py

import subprocess

try:
    completed = subprocess.run(
        'echo to stdout; echo to stderr 1>&2; exit 1',
        shell=True,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
except subprocess.CalledProcessError as err:
    print('ERRORE:', err)
else:
    print('returncode:', completed.returncode)
    print('stdout è {!r}'.format(completed.stdout))
    print('stderr è {!r}'.format(completed.stderr))

</py_code>
<testo_normale>
Il nome <code>DEVNULL</code> proviene dal file speciale di dispositivo di Unix <code>/dev/null</code>, che risponde con un carattere di fine file quando aperto in lettura e riceve ma ignora qualsiasi dato in input quando è aperto in scrittura.
</testo_normale>
<py_output>
$ python3 subprocess_run_output_error_suppress.py

returncode: 1
stdout è None
stderr è None
</py_output>
<titolo_2>
Lavorare Direttamente con le Pipe
</titolo_2>
<testo_normale>
Le funzioni <code>run()</code>, <code>check_call()</code> e <code>check_output</code> sono <a href='https://www.wikiwand.com/it/Wrapper' target='_blank'>wrapper</a> attorno alla classe <code>Popen</code>. L'uso diretto di <code>Popen</code> fornisce maggior controllo sul modo nel quale il comando viene eseguito, e come i suoi canali di input ed output sono elaborati. Ad esempio, passando diversi argomenti per <em>stdin</em>, <em>stdout</em>, e <em>stderr</em> è possibile imitare le varianti di <code>os.popen()</code>.
</testo_normale>
<titolo_3>
Comunicazione Unidirezionale con un Processo
</titolo_3>
<testo_normale>
Per eseguire un processo e leggere tutto il suo output, si imposti il valore di <code>stdout</code> a <code>PIPE</code> e si invochi <code>communicate()</code>.


<py_code>
import subprocess

print '\nlettura:'
proc = subprocess.Popen(['echo', '"to stdout"'],
                        shell=True,
                        stdout=subprocess.PIPE,
                        )
stdout_value = proc.communicate()[0]
print '\tstdout:', repr(stdout_value)
</py_code>
<py_output>
$ python -u subprocess_popen_read.py

lettura:
	stdout: '\n'
</py_output>
<testo_normale>
Scrittura dell'input di una pipe:
</testo_normale>
<py_code>
import subprocess

print '\nscrittura:'
proc = subprocess.Popen(['cat', '-'],
                        shell=True,
                        stdin=subprocess.PIPE,
                        )
proc.communicate('\tstdin: to stdin\n')
</py_code>
<py_output>
$ python -u subprocess_popen_write.py

scrittura:
	stdin: to stdin
</py_output>
<testo_normale>
 <strong>popen2</strong>
</testo_normale>
<testo_normale>
Lettura e scrittura, come popen2:
</testo_normale>
<py_code>
import subprocess

print '\npopen2:'

proc = subprocess.Popen(['cat', '-'],
                        shell=True,
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        )
stdout_value = proc.communicate('attraverso stdin a stdout')[0]
print '\tpassa attraverso:', repr(stdout_value)
</py_code>
<py_output>
$ python -u subprocess_popen2.py
popen2:
	passa attraverso: 'attraverso stdin a stdout'
</py_output>
<testo_normale>
 <strong>popen3</strong>
</testo_normale>
<testo_normale>
Flussi separati per stdout ed stderr, come con popen3:
</testo_normale>
<py_code>
import subprocess

print '\npopen3:'
proc = subprocess.Popen('cat -; echo ";to stderr" 1>&2',
                        shell=True,
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        )
stdout_value, stderr_value = proc.communicate('attraverso stdin a stdout')
print '\tpassa attraverso:', repr(stdout_value)
print '\tstderr:', repr(stderr_value)
</py_code>
<py_output>
$ python -u subprocess_popen3.py

popen3:
	passa attraverso: 'attraverso stdin a stdout'
	stderr: ';to stderr\n'
</py_output>
<testo_normale>
 <strong>popen4</strong>
</testo_normale>
<testo_normale>
stdout ed stderr sono combinati, come con popen4:
</testo_normale>
<py_code>
import subprocess

print '\npopen4:'
proc = subprocess.Popen('cat -; echo ";to stderr" 1>&2',
                        shell=True,
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        )
stdout_value, stderr_value = proc.communicate('attraverso stdin a stdout\n')
print '\tOutput combinato:', repr(stdout_value)
</py_code>
<py_output>
$ python -u subprocess_popen4.py

popen4:
	Output combinato: 'attraverso stdin a stdout\n;to stderr\n'
</py_output>
<titolo_2>
Connettere Segmenti di una Pipe
</titolo_2>
<testo_normale>
Creando istanze separate di Popen e concatenando i loro input ed output, si può creare la propia conduttura di comandi proprio come in una shell Unix.
</testo_normale>
<py_code>
import subprocess

cat = subprocess.Popen(['cat', 'index.rst'],
                        stdout=subprocess.PIPE,
                        )

grep = subprocess.Popen(['grep', '.. include::'],
                        stdin=cat.stdout,
                        stdout=subprocess.PIPE,
                        )

cut = subprocess.Popen(['cut', '-f', '3', '-d:'],
                        stdin=grep.stdout,
                        stdout=subprocess.PIPE,
                        )

end_of_pipe = cut.stdout

print 'File inclusi:'
for line in end_of_pipe:
    print '\t', line.strip()
</py_code>
<py_output>
$ python -u subprocess_pipes.py
File inclusi:
        subprocess_os_system.py
        subprocess_shell_variables.py
        subprocess_popen_read.py
        subprocess_popen_write.py
        subprocess_popen2.py
        subprocess_popen3.py
        subprocess_popen4.py
        subprocess_pipes.py
        repeater.py
        interaction.py
        signal_child.py
        signal_parent.py
        subprocess_signal_parent_shell.py
        subprocess_signal_setsid.py
</py_output>
<titolo_2>
Interagire con un Altro Comando
</titolo_2>
<testo_normale>
Tutti gli esempi sopra riportati presuppongono una limitata interazione. Il metodo <code>communicate()</code> legge tutto l'output ed attende che il processo figlio esca prima di ritornare. E' anche possibile scrivere verso e leggere da singoli gestori di pipe usati dalla istanza di <strong>Popen</strong>. Un semplice programma che legge dallo standard input e scrive verso lo standard output illustra questa situazione:
</testo_normale>
<py_code>
import sys

sys.stderr.write('repeater.py: inizio\n')
sys.stderr.flush()

while True:
    next_line = sys.stdin.readline()
    if not next_line:
        break
    sys.stdout.write(next_line)
    sys.stdout.flush()

sys.stderr.write('repeater.py: uscita\n')
sys.stderr.flush()
</py_code>
<testo_normale>
Si prenda nota del fatto che ${sev}<em>repeater.py</em>${eev}  scrive allo standard error quando parte e si interrompe. Quella informazione può essere usata per mostrare il ciclo di vita del processo figlio.
</testo_normale>
<testo_normale>
Il successivo esempio di interazione usa i gestori di file stdin ed stdout che appartengono all'istanza di <strong>Popen</strong> in modi diversi. Nel primo esempio, una sequenza di 10 numeri vengono scritti allo stdin del processo, e dopo ogni scrittura la successiva riga di output viene riletta. Nel secondo esempio, gli stessi 10 numeri sono scritti ma l'output viene letto in una sola volta usando <code>communicate()</code>.
</testo_normale>
<py_code>
import subprocess

print 'Una riga alla volta:'
proc = subprocess.Popen('python repeater.py',
                        shell=True,
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        )
for i in range(10):
    proc.stdin.write('%d\n' % i)
    output = proc.stdout.readline()
    print output.rstrip()
remainder = proc.communicate()[0]
print remainder

print
print "Tutto l'output in una volta:"
proc = subprocess.Popen('python repeater.py',
                        shell=True,
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        )
for i in range(10):
    proc.stdin.write('%d\n' % i)

output = proc.communicate()[0]
print output
</py_code>
<testo_normale>
Si noti dove le righe ${sev}"repeater.py: uscita"${eev}  si trovano nell'output per ogni ciclo:
</testo_normale>
<py_output>
$ python -u interaction.py
Una riga alla volta:
repeater.py: inizio
0
1
2
3
4
5
6
7
8
9
repeater.py: uscita


Tutto l'output in una volta:
repeater.py: inizio
repeater.py: uscita
0
1
2
3
4
5
6
7
8
9
</py_output>
<titolo_2>
Segnalazioni tra Processi
</titolo_2>
<testo_normale>
Gli esempi di <a href='os.html'>os</a> comprendono una dimostrazione della segnalazione tra processi usando os.fork() ed os.kill(). VIsto che ogni istanza di <strong>Popen</strong> fornisce un attributo <em>pid</em> con l'identificativo del processo figlio, è possibile fare qualcosa di simile con <strong>subprocess</strong>. Ad esempio usare questo script per fare in modo che il processo figlio venga eseguito dal processo genitore:
</testo_normale>
<py_code>
import os
import signal
import time
import sys

pid = os.getpid()
received = False

def signal_usr1(signum, frame):
    """Callback chiamato quando viene ricevuto un segnale"""
    global received
    received = True
    print 'FIGLIO %s: Ricevuto USR1' % pid
    sys.stdout.flush()

print 'FIGLIO %s: Impostazione del gestore di segnale' % pid
sys.stdout.flush()
signal.signal(signal.SIGUSR1, signal_usr1)
print 'FIGLIO %s: In pausa in attesa del segnale' % pid
sys.stdout.flush()
time.sleep(3)

if not received:
    print 'FIGLIO %s: Segnale mai ricevuto' % pid
</py_code>
<testo_normale>
e questo processo genitore:
</testo_normale>
<py_code>
import subprocess
import time
import sys

proc = subprocess.Popen(['python', 'signal_child.py'])
print 'GENITORE: In pausa prima di inviare il segnale...'
sys.stdout.flush()
time.sleep(1)
print 'GENITORE: Segnalazione al figlio'
sys.stdout.flush()
os.kill(proc.pid, signal.SIGUSR1)
</py_code>
<testo_normale>
Il risultato dovrebbe assomigliare a questo:
</testo_normale>
<py_output>
$ python -u signal_parent.py
GENITORE: In pausa prima di inviare il segnale...
FIGLIO 3250: Impostazione del gestore di segnale
FIGLIO 3250: In pausa in attesa del segnale
GENITORE: Segnalazione al figlio
FIGLIO 3250: Ricevuto USR1
</py_output>
<titolo_2>
Processi Gruppi/Sessioni
</titolo_2>
<testo_normale>
A causa del modo in cui funziona l'albero dei processi sotto Unix, se il processo creato da <strong>Popen</strong> genera dei sotto processi, questi suoi figli non riceveranno alcuno dei segnali inviati al genitore, Questo significa, ad esempio, che sarà difficile farli terminare inviandogli un ${sev}SIGINT${eev} od un ${sev}SIGTERM${eev}.
</testo_normale>
<py_code>
import os
import signal
import subprocess
import tempfile
import time
import sys

script = '''#!/bin/sh
echo "Shell script in esecuzione $$"
set -x
python signal_child.py
'''
script_file = tempfile.NamedTemporaryFile('wt')
script_file.write(script)
script_file.flush()

proc = subprocess.Popen(['sh %s' % script_file.name], shell=True, close_fds=True)
print 'GENITORE: In pausa prima di inviare il segnale al figlio %s...' % proc.pid
sys.stdout.flush()
time.sleep(1)
print 'GENITORE: Segnalazione al figlio  %s' % proc.pid
sys.stdout.flush()
os.kill(proc.pid, signal.SIGUSR1)
time.sleep(3)
</py_code>
<testo_normale>
Si noti che il pid usato per inviare il segnale è diverso dal pid del figlio dello script della shell che è in attesa del segnale perchè in questo esempio, ci sono tre processi separati che interagiscono.:
</testo_normale>
<lista_numerata>
${sev}subprocess_signal_parent_shell.py${eev}
un processo della shell Unix che sta eseguento lo script creato dal programma python principale
${sev}signal_child.py${eev}
</lista_numerata>
<py_output>
$ python subprocess_signal_parent_shell.py
GENITORE: In pausa prima di inviare il segnale al figlio 2592...
Shell script in esecuzione 2593
+ python signal_child.py
FIGLIO 2594: Impostazione del gestore di segnale
FIGLIO 2594: In pausa in attesa del segnale
GENITORE: Segnalazione al figlio  2592
FIGLIO 2594: Segnale mai ricevuto
</py_output>
<testo_normale>
La soluzione di questo problema è usare un <a href='http://it.wikipedia.org/wiki/PID_%28Unix%29'><em>gruppo di processi</em></a> da associare ai figli in modo che possa essere inviata una segnalazione a tutti insieme. Il gruppo di processi viene creato con <code>os.setsid()</code>, impostando l'identificativo di sessione ("session id") all'id del processo corrente. Tutti i processi figlio ereditano il "session id", e visto che lo si vuole solamente impostare nella shell creata da <strong>Popen</strong> ed i suoi discendenti non occorre chiamare il processo corrente, al contrario lo si passa come parametro <em>preexec_fn</em> a Popen in mdodo che possa essere eseguito dopo il <code>fork()</code> all'interno del nuovo processo, prima che chiami <code>exec()</code>.
</testo_normale>
<py_code>
import os
import signal
import subprocess
import tempfile
import time
import sys

script = '''#!/bin/sh
echo "Shell script in esecuzione $$"
set -x
python signal_child.py
'''
script_file = tempfile.NamedTemporaryFile('wt')
script_file.write(script)
script_file.flush()

proc = subprocess.Popen(['sh %s' % script_file.name],
                        shell=True,
                        close_fds=True,
                        preexec_fn=os.setsid,
                        )
print 'GENITORE: In pausa prima di inviare il segnale al figlio %s...' % proc.pid
sys.stdout.flush()
time.sleep(1)
print 'GENITORE: Segnalazione del gruppo di processo %s' % proc.pid
sys.stdout.flush()
os.killpg(proc.pid, signal.SIGUSR1)
time.sleep(3)
</py_code>
<testo_normale>
Per segnalare all'intero gruppo di processi, si usa <code>os.killpg()</code> con il valore del pid dall'istanza di <strong>Popen</strong>
</testo_normale>
<py_output>
$ python subprocess_signal_setsid.py
GENITORE: In pausa prima di inviare il segnale al figlio 2957...
Shell script in esecuzione 2958
+ python signal_child.py
FIGLIO 2959: Impostazione del gestore di segnale
FIGLIO 2959: In pausa in attesa del segnale
GENITORE: Segnalazione del gruppo di processo 2957
FIGLIO 2959: Ricevuto USR1
</py_output>
<titolo_2>
Conclusioni
</titolo_2>
<testo_normale>
Come si vede, lavorare con <strong>subprocess</strong> è molto più facile di fork, exex, e le pipe da soli. Fornisce tutte le funzionalità degli altri moduli e delle funzioni che sostituisce, ed altro. L'API è consistente per tutti gli utilizzi e la maggior parte dell'attività extra necessaria (tipo chiudere i descrittori di file extra, assicurarsi che le pipe siano chiuse, ecc) sono incorporate in esso invece che dover essere gestite separatamente dal codice della propria applicazione.
</testo_normale>
<vedi_anche>
http://docs.python.org/lib/module-subprocess.html|subprocess|La documentazione della libreria standard per questo modulo.
os.html|os|Sebbene molte di esse siano deprecate, le funzioni per lavorare con i processi contenute nel modulo os sono ancora largamente usate nel codice esistente.
http://www.amazon.com/Programming-Environment-Addison-Wesley-Professional-Computing/dp/0201433079/ref=pd_bbs_3/002-2842372-4768037?ie=UTF8&s=books&amp;qid=1182098757&sr=8-3|Unix Signals and Process Groups|Una buona descrizione delle segnalazioni in Unix e come i gruppi di processi funzionano.
http://www.amazon.com/Programming-Environment-Addison-Wesley-Professional-Computing/dp/0201433079/ref=pd_bbs_3/002-2842372-4768037?ie=UTF8&s=books&amp;qid=1182098757&sr=8-3|Advanced Programming in the UNIX(R) Environment|Tratta il lavorare con processi multipli, tipo la gestione di segnali, la chiusura di descrittori di file duplicati, ecc.
pipes.html|pipe|modelli di pipeline di comandi della shell unix nella libreria standard
</vedi_anche>
</documento_tradotto>
